// Отчет https://contest.yandex.ru/contest/25597/run-report/64486689/

/*
-- ПРИНЦИП РАБОТЫ --

Требуется найти минимальное число операций за которое можно преобразовать строку str1 в str2. При этом, к
возможным операциям относятся:
1. замена одного символа на другой;
2. удаление символа из строки str1;
3. добавление символа в строку str1;

Идея состоит в том, чтобы рассматривать по одному символу начиная с конца строк str1 в str2.
Если последние символы str1[n - 1], str2[m - 1] строк совпадают, то преобразование не требуется и
минимальное число операций остается таким же как для строк str1[n - 2] и str2[m - 2] -
minDist(str1[n - 2], str2[m - 2]), где minDist(str1[i], str2[j]) - рекурсивная функция, возвращающая
минимальное число операций для строк длины i, j соответственно.

Иначе, если символы различны, то к последнему символу строки str1 возможно применить 3 операции.
1. При замене символа, ситуация аналогична совпадению, но число операций увеличилось на 1
- minDist(str1[n - 2], str2[m - 2]) + 1.
2. При удалении символа из строки str1, рассматриваем значение функции minDist для предыдущего символа
строки str1[n - 2] и текущего символа строки str2[m - 1], число операций увеличилось на 1 -
minDist(str1[n - 2], str2[m - 1]) + 1.

Пример:
01234    0123
abcfd    abcf
  bcf ->  bcf
  012     012

3. При вставке символы совпали - рассматриваем значение функции для текущего символа
строки str1[n - 1] и предыдущего символа строки str2[m - 2] + 1 операция - minDist(str1[n - 1], str2[m - 2]) + 1.
Из трех значений выбираем минимум.

Пример:
0123    01234   0123 4
abcb    abcbc   abcb c
  bc ->    bc ->   b c
  01       01      0 1

Запишем задачу в терминах динамического программирования:

1.Что будет храниться в dp?
Массив dp[i][j] хранит минимальное число операций за которое можно преобразовать строку str1[0..i - 1] в str2[0..j - 1],
где i = 0, .. n, j = 0, .. m.

2.Каким будет базовый случай для задачи?
Строка str1 размера 0 может быть преобразована в строку str2 размера j, за j операций. Поэтому заполняем первую строку
матрицы n + 1 x m + 1 числами 0, 1, ..., j:

 for (int j = 0; j <= m; j++)
    dp[0][j] = j;

Строка str1 размера i может быть преобразована в строку str2 размера 0, за i операций. Поэтому заполняем первый столбец
матрицы числами 0, 1, ..., i:

for (int i = 0; i <= n; i++)
    dp[i][0] = i;

3.Каким будет переход динамики?

Согласно описанному выше рекуррентному соотношению:
* Если символы совпадают str1[i - 1] == str2[j - 1], то dp[i][j] = dp[i - 1][j - 1].
* Иначе, dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])) + 1.
- минимум из значений, полученных путем применения трех операций к текущему символу i - 1 строки str1.

4.Каким будет порядок вычисления данных в массиве dp?
Заполняем сначала целиком первую строку размера m матрицы, потом вторую и так далее — пока не заполним n-ю строку.

5.Где будет располагаться ответ на исходный вопрос?
Для исходных строк str1[0..n - 1] в str2[0..m - 1] - в ячейке dp[n][m] по определению dp.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Будем доказывать с помощью индукции по ячейкам слева направо, сверху вниз.

База индукции:
dp[0][j] = j для j = 0, .. m.
dp[i][0] = i для i = 0, .. n

Т.к. таблица заполняется по строками слева на право, сверху вниз, то для всех i'<i, j'<j значение d[i'][j'] заполнено и корректно.
Пусть утверждение выполняется для i, j:

           {if (str1[i - 1] == str2[j - 1]) dp[i - 1][j - 1]
dp[i][j] = {
           {else min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1

При переходе к следующей ячейке возможно 2 варианта:
1. при переходе по строке изменится индекс j -> j + 1
2. при смене строки индекс i - > i + 1, j -> 1

Рассмотрим шаг индукции по i и по j. Докажем, что утверждение верно для dp[i][j + 1] и dp[i + 1][j].

Используя формулу выше для dp[i][j], переобозначая j -> j + 1, i -> i + 1 получим ожидаемый результат:

               {if (str1[i - 1] == str2[j]) dp[i - 1][j]
dp[i][j + 1] = {
               {else min(dp[i - 1][j], dp[i - 1][j + 1], dp[i][j]) + 1

               {if (str1[i] == str2[j - 1]) dp[i - 1][j - 1]
dp[i + 1][j] = {
               {else min(dp[i - 1][j], dp[i - 1][j + 1], dp[i][j]) + 1

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --

Временная сложность O(n * m), так как мы должны обновить каждую из ячеек массива dp,
состоящего из n строк и m столбцов. Каждое обновление происходит за O(1).

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --

Пространственная сложность O(n * m), так как мы должны хранить массив dp, состоящий из n строк и m столбцов.

При оптимизации, используем массив, состоящий из 2 строк и m столбцов, т.е. O(2 * m).

*/

#include <iostream>
#include <vector>
#include <algorithm>
#include <string>

int main()
{
    std::string str1;
    std::cin >> str1;

    std::string str2;
    std::cin >> str2;

    int n = static_cast<int>(str1.size());
    int m = static_cast<int>(str2.size());

    std::vector<std::vector<int>> dp(2, std::vector<int>(m + 1));

    for (int j = 0; j <= m; j++)
        dp[0][j] = j;

    for (int i = 1; i <= n; i++)
    {
        int k = i % 2;
        int kPrev = (i + 1) % 2;

        dp[k][0] = i;

        for (int j = 1; j <= m; j++)
        {
            if (str1[i - 1] == str2[j - 1])
                dp[k][j] = dp[kPrev][j - 1];
            else
                dp[k][j] = std::min(dp[kPrev][j - 1], std::min(dp[kPrev][j], dp[k][j - 1])) + 1;
        }
    }

    std::cout << dp[n % 2][m] << std::endl;

    return 0;
}