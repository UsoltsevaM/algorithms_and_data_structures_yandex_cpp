// Отчет https://contest.yandex.ru/contest/25597/run-report/64527085/

/*
-- ПРИНЦИП РАБОТЫ --

Требуется понять, можно ли разбить данную последовательность на две подпоследовательности с одинаковыми суммами.

Идея решения:
1. Посчитаем сумму чисел в последовательности (исходном массиве). Если она нечетная, то разбить не получится. 
2. Если сумма sum - четная, то предположительно могут быть 2 подпоследовательности с суммами sum / 2.
При это, если удастся найти подпоследовательность с суммой sum / 2, то оставшиеся числа также сформируют 
подпоследовательность с суммой sum / 2.

Запишем задачу в терминах динамического программирования:

1.Что будет храниться в dp?
Массив dp[i][j] хранит значение: 
* true, если существует ли подпоследовательность в последовательности 
{{}, arr[0], arr[1], .., arr[j - 1]}, которая дает в сумме i, где i = 0, .. sum / 2 + 1, j = 0, .. arr.size() + 1, n = arr.size() 
* false иначе.

2.Каким будет базовый случай для задачи?
Для искомой суммы i = 0, заполним первую строку матрицы значение true:

for (int j = 0; j <= n; j++)
    dp[0][j] = true;

т.к. все числа в последовательности положительны, и если на каком то шаге i - arr[j - 1] == 0, значит 
нужная сумма набрана (см пункт 3). 

Для пустой последовательности длины 0 любая сумма не может быть набрана:
for (int i = 1; i <= m; i++)
    dp[i][0] = false;

где m = sum / 2.

3.Каким будет переход динамики?

Для определения dp[i][j] рассмотрим последний arr[j - 1] элемент последовательности {}, arr[0], arr[1], .., arr[j - 1].
Если он больше суммы i, arr[j - 1] > i, которую нужно набрать для последовательности длины j, то его брать не нужно.
Значение dp[i][j] будет определятся значением dp[i][j - 1] для последовательности длины j - 1.
Если arr[j - 1] <= i, то этот элемент может быть включен в искомую подпоследовательность, если 
dp[i - arr[j - 1]][j - 1] = true. Т.к. если в последовательности длины j - 1 найдется подпоследовательность 
с суммой i - arr[j - 1], то на jм шаге к ней добавится элемент arr[j - 1] и в последовательности длины j
найдется подпоследовательность с суммой i.
Если подпоследовательности длины j - 1 с суммой i - arr[j - 1] не нашлось, элемент arr[j - 1] не нужно включать 
в искомую подпоследовательность. Значит значение dp[i][j] по прежнему определяется значением dp для последовательности
длины  j - 1, dp[i][j] =  dp[i][j - 1].

Более кратко:

 if (arr[j - 1] > i)
     dp[i][j] = dp[i][j - 1];
 else
     dp[i][j] = dp[i][j - 1] || dp[i - arr[j - 1]][j - 1];

Пример:
Последовательность 2 2 1 3
sum = 2 + 2 + 1 + 3 = 8
sum / 2 = 8 / 2 =4

   {} 2 22 221 2213
0  T  T  T  T   T
1  F  F  F  T   T
2  F  T  T  T   T
3  F  F  F  T   T
4  F  F  T  T   T

4.Каким будет порядок вычисления данных в массиве dp?
Для каждой из сумм i от 0, .. sum / 2 заполняем по порядку строки j = 0 до n для последовательностей 
{}, { {}, arr[0]}, .. {{}, arr[0], .. arr[n - 1]}.

5.Где будет располагаться ответ на исходный вопрос?
Для искомой суммы sum / 2 и последовательности длины n - в ячейке dp[sum / 2][n] по определению dp.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --

Будем доказывать с помощью индукции по ячейкам слева направо, сверху вниз.

База индукции:
dp[0][j] = true; для j = 0, .. n.
dp[i][0] = false для i = 0, .. m.

Т.к. таблица заполняется по строками слева на право, сверху вниз, то для всех i'<i, j'<j значение d[i'][j'] заполнено и корректно.
Пусть утверждение выполняется для i, j:

           {if (arr[j - 1] > i) dp[i][j - 1]
dp[i][j] = {
           {else dp[i][j - 1] || dp[i - arr[j - 1]][j - 1]

При переходе к следующей ячейке возможно 2 варианта:
1. при переходе по строке изменится индекс j -> j + 1
2. при смене строки индекс i - > i + 1, j -> 1

Рассмотрим шаг индукции по i и по j. Докажем, что утверждение верно для dp[i][j + 1] и dp[i + 1][j].

Используя формулу выше для dp[i][j], переобозначая j -> j + 1, i -> i + 1 получим ожидаемый результат:

               {if (arr[j] > i) dp[i][j]
dp[i][j + 1] = {
               {else dp[i][j] || dp[i - arr[j]][j]

               {if (arr[j - 1] > i + 1) dp[i + 1][j - 1]
dp[i + 1][j] = {
               {else dp[i + 1][j - 1] || dp[i + 1 - arr[j - 1]][j - 1]

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --

Временная сложность O((sum / 2) * n), так как мы должны обновить каждую из ячеек массива dp,
состоящего из sum / 2 строк и n столбцов. Каждое обновление происходит за O(1).

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --

Пространственная сложность O((sum / 2) * n), так как мы должны хранить массив dp, состоящий из sum / 2 строк и n столбцов.

Оптимизация:

В предыдущей формуле dp[i][j] на каждом шаге обращение происходит к j - 1 столбцу, сведем к одной строке или столбцу.

Пусть dp[i] - true, если для последовательности длины j есть подпоследовательность с суммой равной i, false иначе.

Заполняем первую строку значениями false
for (int i = 1; i <= m; i++)
   dp[i] = false;
т.к. не можем набрать из подпоследовательности длины j сумму i.

Далее, цикл 
for (int j = 1; j <= n; j++)
увеличивает на каждом шаге длину последовательности.

Цикл
for (int i = m; i >= arr[j - 1]; i--)
рассматривает возможные суммы от sum / 2 до arr[j - 1]. Начинаем с максимальной суммы, чтобы не перебирать лишние ячейки.

Условие i >= arr[j - 1] проверяет, что текущий рассматриваемый элемент последовательности меньше нужной суммы i. 
Если arr[j - 1] > i выполняется, то элемент последовательности и не включается в искомую подпоследовательность и 
все суммы меньше, чем i можно не рассматривать.

Далее возможны варианты, при которых arr[j - 1] включается в искомую подпоследовательность:
* Сумма i уже найдена на предудущем шаге j - 1 - dp[i] = true.
* Разность i - arr[j - 1] > 0 уже найдена на предыдущем шаге, т.е. dp[i - arr[j - 1]] = true и arr[j - 1] включается
в искомую подпоследовательность.
* Текущий рассматриваемый элемент последовательности arr[j - 1] равен искомой сумме i -> dp[i - arr[j - 1]] = dp[0] = true;

Это сводится к условию:
if (dp[i - arr[j - 1]])
   dp[i] = true;

Результат будет храниться в dp[sum / 2].

Память потребуется под массив dp из sum / 2 + 1 ячеек -  O(sum / 2).

*/

#include <iostream>
#include <vector>

int main()
{
    int n = 0;
    std::cin >> n;

    int sum = 0;
    std::vector<int> arr(n);
    for (int i = 0; i < n; i++)
    {
        std::cin >> arr[i];
        sum += arr[i];
    }

    if (sum % 2 != 0)
    {
        std::cout << "False";
        return 0;
    }

    int m = sum / 2;
    std::vector<bool> dp(m + 1);

    dp[0] = true;

    for (int i = 1; i <= m; i++)
      dp[i] = false;

    for (int j = 1; j <= n; j++)
        for (int i = m; i >= arr[j - 1]; i--)
            if (dp[i - arr[j - 1]])
                dp[i] = true;

    if (dp[m])
        std::cout << "True";
    else
        std::cout << "False";

    return 0;
}