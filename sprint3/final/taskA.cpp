// Отчет https://contest.yandex.ru/contest/23815/run-report/55951993/

/*
-- ПРИНЦИП РАБОТЫ --

Пусть arr - исходный массив размера n.
Решение состостоит из 2х шагов:
1. Бинарным поиском найти минимальный элемент массива, который разбивает массив на 2 отсортированные части:
arr[0] <= ... arr[max] >= arr[min] ... <= arr[n-1]
2. Осуществить бинарный поиск k в одной из частей массива.

Функция firstElementLessThanVal() принимает исходный массив и осуществляет поиск позиции минимального элемента массива как
первого элемента меньшего первого элемента массива arr[0]. Если такой элемент не найден (позиция равна длине массива arr.size()), 
значит массив находится в отсортированном состоянии. Далее достаточно бинарным поиском найти заданный элемент k.

Если найдена позиция min минимального элемента, значит нужно выполнить бинарный поиск binarySearch():
* Если k >= arr[min] && k <= arr[n-1]  - в правой половине массива [min, n);
* Если k >= arr[0] && k < arr[min]  - в левой половине массива [0, min).

Результат binarySearch() вернет искомую позицию числа k.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --

Входные данные - кольцевой буфер с данными, отсортированными по возрастанию. Он был сдвинут на некторое число позиций.
Сдвиг массива означает его разбиение на 2 части с сохранением порядка. При перемещение на m позиций вправо m элементов
переместятся в начало массива, сохраняя порядок, по определению кольцевого буфера. Аналогично при сдвиге влево m элементов
переместятся в конец массива. На m позиций переместиться и минимальный элемент массива. Перед ним будет стоять последовательность 
из m или n - m отсортированных по возрастанию элементов, больших или равных минимальному элементу. 
Следовательно, для того чтобы найти позицию минимального элемента, достаточно взять первый элемент arr[0] последовательности, 
стоящей перед ним (arr[0] <= ... arr[max]), и найти первый элемент меньший arr[0] в массиве arr[1 .. n-1].

Поиск можно осущетвить за логарифмическое время.
Пусть val = arr[0], left = 1 - исходная левая граница, right = n - исходная правая граница.
Ищем первый элемент, на котором не выполнится предикат val <= arr[mid].
Будем сравнивать val = arr[0] cо средним элементом arr[mid] массива arr[1 .. n-1]:
1. Если val <= arr[mid], значит mid указвает на один из элементов отсортированной последовательности
arr[0] <= .. <= arr[mid] <= .. arr[max]
и искать минимальный элемент нужно в другой части массива - [mid+1, right) - мы получили левую границу для дальнейшего поиска.
2. Если val > arr[mid], то mid будет указывать на один из элементов отсортированной последовательности
arr[min] <= .. <= arr[mid] <= .. arr[n-1], получим правую границу для поиска. Поиск нужно продолжить в интервале [left, mid), 
просматривать числа, начиная с mid + 1 нет смысла, т.к. они больше arr[mid]. 
3. Когда right <= left, left будет содержать искомый индекс минимального элемента.

Пример:

arr 5 6 1 2 3 4
idx 0 1 2 3 4 5

arr[0] = val = 5;
1. mid = 3; arr[3] = 2; 5 > 2 => idx [1, 3)
2. mid = 2; arr[2] = 1; 5 > 1 => idx [1, 2)
3. mid = 1; arr[1] = 6; 5 <= 6 => idx [2, 2)
=> arr[2] = 1.

Позиция min найдена, значит найдено разбиение массива arr[0] <= ... arr[max] >= arr[min] ... <= arr[n-1].
Если min = n, значит массив отсортирован. Используем бинарный поиск на всем массиве [0, n).

Иначе, ищем бинарным поиском элемент k:
* Если k >= arr[min] && k <= arr[n - 1]  - в правой половине массива [min, n);
* Если k >= arr[0] && k < arr[min] - в левой половине массива [0, min).

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --

1. Сложность поиска позиции минимального элемента - O(logn), т.к. на кажом шаге происходит одно сравнение за O(1)
и деление массива пополам. Максимальная глубина дерева рекурсии O(logn).
2. Далее в зависимости от выполенеия условия val <= arr[mid] выполняется классический бинарный поиск
на одно из интервалов [0, min) или [min, n) за O(logn).

Итоговая сложность алгоритма - O(logn).

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --

Обе функции firstElementLessThanVal() и binarySearch() не требуют дополнительной памяти, кроме как на хранение
среднего элемента массива и правой и левой границ - O(1). Учитывая число шагов рекурсии -  O(logn).

Для хранения исходного массива с данными потребуется - O(n).
Итоговая пространственная сложность  O(n + logn) ~ O(n).
*/

#include <vector>
#include <cassert>

int firstElementLessThanVal(const std::vector<int>& arr, int val, int left, int right)
{
	if (right <= left)
		return left;

	int mid = (left + right) / 2;
	if (val <= arr[mid])
		return firstElementLessThanVal(arr, val, mid + 1, right);
	return firstElementLessThanVal(arr, val, left, mid);
}

int binarySearch(const std::vector<int>& arr, int val, int left, int right)
{
	if (right <= left)
		return -1;

	int mid = (left + right) / 2;

	if (arr[mid] == val)
		return mid;
	if (val < arr[mid])
		return binarySearch(arr, val, left, mid);
	return binarySearch(arr, val, mid + 1, right);
}


int broken_search(const std::vector<int>& vec, int k)
{
	int min = firstElementLessThanVal(vec, vec[0], 1, vec.size());
	if (min >= vec.size())
		return binarySearch(vec, k, 0, vec.size());

	if (k >= vec[min] && k <= vec[vec.size() - 1])
		return binarySearch(vec, k, min, vec.size());

	return binarySearch(vec, k, 0, min);
}

void test() {
	std::vector<int> arr = { 1, 2 ,3 ,5, 6, 7, 9, 0 };
	assert(2 == broken_search(arr, 1));
}
