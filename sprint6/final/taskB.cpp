// Отчет https://contest.yandex.ru/contest/25070/run-report/63175666/

/*
-- ПРИНЦИП РАБОТЫ --

Требуется определить является ли карта дорог оптимальной.
Карта железных дорог называется оптимальной, если не существует пары городов A и B такой,
что от A до B можно добраться как по дорогам типа R, так и по дорогам типа B.
От одного города до другого можно проехать только по маршруту, состоящему исключительно из дорог типа R или только из дорог типа B.
По дорогам страны X можно двигаться только от города с меньшим номером к городу с большим номером.

Т.е. по условию задачи дан ориентированный граф с типами ребер R и B, все ребра которого направлены от вершин с меньшими
номерами к вершинам с большими номерами. Данный граф с типами ребер R и B можно превратить в равнозначный, таким образом,
что ребра типа R будут задавать направление от города с меньшим номером к городу с большим номером, а ребра типа
B - противоположное направление.
Т.е. применим к графу функцию F, такую, что ребра типа R она оставит без изменения, у ребер типа B инвертирует направление.
Если в графе были бы ребра от большего города к меньшему, такое преобразование нельзя было бы выполнить, т.к. не возможно бы
было установить взаимно однозначное соответствие F из типа ребра в его направление.
Тогда, если существует пара городов A и B такая, что от A до B можно добраться как по дорогам типа R, так и по дорогам типа B -
значит в графе существует цикл.

Алгоритм использует обход графа в глубину с поиском цикла.
1. Изначально все вершины покрашены в белый цвет, color = -1.
2. Для каждой белой вершины вызывается DFS. Проверка на цвет включена в функцию DFS - (colors[curVert] == -1).
DFS будет окрашивать в черный цвет вершины внутри одной компоненты связности. Цикл по всем вершинам требуется,
чтобы рассмотреть все вершины, в т.ч. в разных компонентах связности.

DFS():
Использует структуру стек, чтобы избежать переполнения стека вызовов.
К каждой вершине алгоритм должен обратиться дважды. В первый раз на пути «вперёд» по графу алгоритм заходит в
вершину и перекрашивает её в серый цвет. Во второй раз мы возвращаемся к вершине на обратном пути и перекрашиваем её в чёрный цвет.
Если в графе найден цикл, то
- Положим на стек стартовую вершину. Пусть это будет вершина с индексом 0.
- Пока стек не пуст, получаем из стека очередную вершину curVert. Это может быть как новая вершина, так и уже посещённая однажды.

3. Если цвет вершины белый colors[curVert] == -1, она не была посещена - красим вершину в серый и кладём её обратно в стек
(это позволит алгоритму позднее вспомнить обратный путь по графу).
3.1. Рассамтриваем все соседние вершины. Если вершина не посещена, то кладем ее на стек, если же цвет рассматриваемой вершины серый -
значит мы нашли цикл на текущем пути - можно прервать DFS и вернуть false.
4. Если цвет вершины серый значит мы ее уже посетили. Серую вершину мы могли получить из стека только на обратном пути.
Следовательно, её следует перекрасить в чёрный.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --

Докажем, что F - взаимно однозначное отображение и существование цикла эквивалентно существованию пути R и пути B между парой городов.
Пусть исходный граф G можно отобразить в 2 графа G1 и G2, и G1 и G2 не совпадают. Т.к. мы оперируем только направлением ребер,
значит существует AB ребро в G1, такое что его направление не совпадает с направлением ребра AB в G2, а это значит, что в исходном
графе данные ребра имеют разные типы, что невозможно. Значит F отображает G в G1 взаимно однозначно.
Пуст карта оптимальна и в графе G1 есть цикл между вершинами A и B, A < B.
Переходя графа G1 к G путем замены ребер с направлением от меньшего к большему (от A к B) на тип R, а от большего к меньшему
(от B к A) на тип B получим наличие двух путей из A в B, что противоречит оптимальности карты.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --

Каждое ребро должно быть пройдено ровно один раз, и каждая вершина должна быть посещена ровно один раз.
Если граф представлен списками смежности, то перебрать все смежные вершины можно за время,
пропорциональное числу этих вершин. Т.е. мы перебираем рёбра, исходящие из вершины.
Поскольку алгоритм обрабатывает все вершины, ему придётся пройтись по всем спискам смежности.
Это эквивалентно тому, чтобы пройти по каждому ребру по одному разу, что займёт O(|E|). Получим,
что итоговая сложность алгоритма O(|V| + |E|). В худшем случае для полного графа  O(|V^2|).

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --

Граф представлен списками смежности - следовательно, занимаемая память O(|V|+|E|).
DFS использует стек для хранения вершин, который занимает O(|V|).
Общая пространственная сложность O(|V|+|E|).

*/

#include <iostream>
#include <vector>
#include <stack>
#include <algorithm>

bool DFS(int startVert, const std::vector<std::vector<int>>& graph, std::vector<int>& colors)
{
    std::stack<int> st;
    st.push(startVert);

    while (!st.empty())
    {
        auto curVert = st.top();
        st.pop();

        if (colors[curVert] == -1)
        {
            colors[curVert] = 0;
            st.push(curVert);

            for (const auto& adj : graph[curVert])
            {
                if (colors[adj] == -1)
                    st.push(adj);
                else if (colors[adj] == 0)
                    return false;
            }

        }
        else if (colors[curVert] == 0)
            colors[curVert] = 1;
    }

    return true;
}

int main()
{
    int n = 0;
    std::cin >> n;

    std::vector<std::vector<int>> graph(n);
    for (int i = 0; i < n; ++i)
        for (int j = i + 1; j < n; ++j)
        {
            char type;
            std::cin >> type;

            if (type == 'R')
                graph[i].push_back(j);
            else
                graph[j].push_back(i);
        }

    std::vector<int> colors(n);
    for (int i = 0; i < n; ++i)
        colors[i] = -1;

    for (int i = 0; i < n; ++i)
        if (!DFS(i, graph, colors))
        {
            std::cout << "NO";
            return 0;
        }

    std::cout << "YES";
  
    return 0;
}