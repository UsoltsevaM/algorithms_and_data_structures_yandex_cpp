// Отчет https://contest.yandex.ru/contest/24810/run-report/61156309/

/*
-- ПРИНЦИП РАБОТЫ --

Дан массив участников, тербуется отсортировать его с использованием пирамидальной сортировки по
следующим критериям в заданном порядке:
1. По возрастанию числа решенных задач;
2. По убыванию штрафа;
3. В лексикографическом порядке имен участников.

Данные об участнике хранятся в структуре:

struct Participant
{
    std::string name; - имя участника
    int tasks = 0; - количество решенных задач
    int fine = 0; - штраф
};

Сравнение участников согласно приоритету реализует оператор - operator>(). Для удобства знак
числа задач инвертирован, далее, больший приоритет имеют участники с меньшим штрафом, далее, с
меньшим именем согласно лексикографическому сравнению.

Для сортировки используется бинарная невозрастающая куча (max-heap) - законченное бинарное дерево
(т.е. полностью насыщенное узлами, за исключением крайних правых узлов последнего уровня), у
которого каждый узел меньше своих дочерних узлов. Корневой узел - самый максимальный (приоритетный).
Куча реализована в виде массива, где для узла с индексом idx, родительский узел лежит по индексу
parentIdx = [idx / 2], где - [] отбрасывание дробной части, индекс левого потомка узла idx
равен 2 * idx, правого -  2 * idx + 1.

Алгоритм:

Функция heapSort(std::vector<Participant>& participants):
1. Создадим пустую бинарную max-кучу. Она будет представлять из себя массив из heap.size() - 1
элементов, т.к. нумерация массива начинается с 1. Первый элемент - фиктивный.
2. Вставим в нее по одному все элементы массива participants, сохраняя свойства кучи. На вершине
пирамиды должен оказаться самый приортетный элемент. Для этого используем функцию добавления элемента
в кучу - heapAdd().

Функция heapAdd(std::vector<Participant>& heap, const Participant& p):
- Добавить элемент p в конец массива кучи heap.
- Для восстановления свойства кучи вызвать функцию просеивания вверх - siftUp(), тогда
элемент p займет правильное место в куче.

Функция int siftUp(std::vector<Participant>& heap, int idx):
- Если элемент с индексом idx уже на вершине кучи heap - ничего делать не требуется, возвращаем его индекс.
- Иначе, вычислим индекс родительского узла - parentIdx = idx / 2, где / - целочисленное деление.
- Пока элемент не на вершине кучи или больше родительского узла - heap[idx] > heap[parentIdx],
обмениваем значение родельского узла и текущего между собой.
Таким образом, по завершению siftUp(), элемент будет удовлетворять свойству max кучи -
т.е. будет больше своих дочерних узлов.

3. После того, как все элементы вставлены в кучу, будем снимать с вершины по одному самому приоритетному
элементу с помощью функции popMax() и перезаписывать значения в исходном массиве participants пока размер
кучи не равен нулю, т.е. heap.size() > 1. В итоге, в массиве кучи останется один фиктивный элемент по индексу 0.

Функция Participant popMax(std::vector<Participant>& heap):
- Запомним самый приоритетный элемент в result = heap[1].
- На место извлеченного элемента поставим последний элемент из кучи - heap[heap.size() - 1].
- Уменьшим размер массива кучи на 1.
- Восстановим свойство кучи с помощью функции просеивания вершинного элемента вниз siftDown().
- Вернем result.

Функция int siftDown(std::vector<Participant>& heap, int idx):
- Вычислим индексы левого и правого потомков текущего элемента с индексом idx. Они будут равны
leftIdx = 2 * idx, rightIdx = 2 * idx + 1.
- Если выполняется условие leftIdx >= heap.size(), т.е. индекс левого узла совпадает с границей
массива кучи, то у элемента нет дочерних узлов, он уже занял свое место в куче, возвращаем его индекс.
Для того чтобы сохранить свойства max кучи, требуется найти максимальный из дочерних элементов и
совершить обмен с текущим, при условии, что он меньше дочернего.
- При условии rightIdx < heap.size() у элемента есть оба дочерних узла - выбираем максимум из
heap[rightIdx] и heap[leftIdx].
- Если rightIdx >= heap.size(), значит текущий элемент имеет только левый дочерний узел и его
значение heap[leftIdx] будет максимальным из дочерних узлов.
- Далее, если текущий элемент heap[idx] меньше максимального дочернего элемента heap[maxIdx], то нужно
произвести обмен элементов heap[idx] и heap[maxIdx].
- Повторяем все операции с начала, пока элемент не станет листовым или выполняется условие
heap[idx] < heap[maxIdx], т.е. значение текущего элемента больше значений его потомков.

По завершению siftDown(), элемент будет удовлетворять свойству max кучи - т.е. будет больше своих
дочерних узлов или станет листовым.

4. Когда в массиве кучи останется только фиктивный элемент (heap.size() == 1), все элементы кучи будут перезаписаны в
исходный массив participants в порядке приоритета.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --

Max куча обеспечивает то, что на шаге 3 с вершины кучи будет сниматься самый приоритетный элемент,
таким образом в конечный массив будут записаны участники в порядке убывания приоритета.

Корректность - сохранение свойств бинарной невозрастающей кучи в ходе алгоритма.
Сохранение свойств кучи гарантируется функциями siftUp() и siftDown().
При вставке каждого элемента в конец массива кучи вызывается siftUp(), которая производит
обмен элемента с родительским пока он не займет правильное место в куче - будет больше своих
дочерних узлов.

При снятии с вершины самого приоритетного элемента свойства кучи восстанавливаются функцией
siftDown(). Сначала на вершину кучи кладется наименее приоритетный элемент из конца массива -
свойство кучи нарушается. Затем пока элемент не станет листовым или не выполняется условие
heap[idx] больше своих потомков, происходит обмен с наболее приоритетным потомком. Таким образом,
элемент с вершины займет верную позицию в куче, свойство кучи восстановится, на вершине окажется
наболее приоритетный элемент.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --

Пусть n - исходное число участников массиве participants. Создание бинарной кучи будет равно O(1).
Далее вставим n элементов подряд в бинарную кучу. Т.к при вставке элемента в кучу мы на каждом
уровне проводим только одно сравнение элемента, а куча имеет высоту logk (т.к. она является законченным
бинарным деревом), где k - количество ее элементов, то вставка происходит за O(logk).
При вставке элементов размер k кучи будет равен k = 1, 2, ..., n, т.е. общая сложность -
O(log1) + O(log2) + ... + O(logn) < O(logn) + ... + O(logn) ~ O(nlogn) - оценка сверху.
Добавление всех участников в кучу займет O(nlogn).

Так как при удалении мы на каждом уровне дерева проводим не более двух сравнений элемента, а куча
имеет высоту O(logk), то удаление элмента происходит за O(logk). При удалении n участников k принимает
следующие значения - k = n, n - 1, ... 1, т.е. общая сложность - O(logn) + O(logn-1) + ... + O(log1) ~ O(nlogn).
Удаление всех участников из кучи займет O(nlogn).

Общая сложность составит - O(1) + O(nlogn) + O(nlogn) ~ O(nlogn).

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --

Пусть n - исходное число участников в массиве participants. Тогда потребуется O(n) памяти на хранение
исходного массива участников и O(n + 1) памяти для хранения max кучи в виде линейного массива.
Т.е. всего потребуется O(n) + O(n + 1) ~ O(2n + 1) ~ O(n) памяти.

*/

#include <vector>
#include <algorithm>
#include <iostream>
#include <tuple>
#include <string>

struct Participant
{
    std::string name;
    int tasks = 0;
    int fine = 0;
};

bool operator>(const Participant& p1, const Participant& p2)
{
    if (p1.tasks != p2.tasks)
        return p1.tasks > p2.tasks;
    if (p1.fine != p2.fine) 
        return p1.fine < p2.fine;
    return p1.name < p2.name;
}

bool operator<(const Participant& p1, const Participant& p2)
{
    return p2 > p1;
}

std::istream& operator>> (std::istream& is, Participant& p)
{
    is >> p.name >> p.tasks >> p.fine;
    return is;
}

int siftDown(std::vector<Participant>& heap, int idx)
{
    int leftIdx, rightIdx, maxIdx = 0;
    while (2 * idx < heap.size())
    {
        leftIdx = 2 * idx;
        rightIdx = 2 * idx + 1;
        maxIdx = (rightIdx < heap.size() && heap[rightIdx] > heap[leftIdx]) ? rightIdx : leftIdx;

        if (heap[maxIdx] < heap[idx])
            return idx;

        std::swap(heap[idx], heap[maxIdx]);
        idx = maxIdx;
    }

    return idx;
}

int siftUp(std::vector<Participant>& heap, int idx)
{
    while (idx > 1 && heap[idx] > heap[idx / 2])
    {
        std::swap(heap[idx], heap[idx / 2]);
        idx = idx / 2;
    }

    return idx;
}

void heapAdd(std::vector<Participant>& heap, const Participant& p)
{
    heap.push_back(p);
    siftUp(heap, static_cast<int>(heap.size()) - 1);
}

Participant popMax(std::vector<Participant>& heap)
{
    Participant result = heap[1];
    heap[1] = heap[heap.size() - 1];
    heap.pop_back();
    siftDown(heap, 1);
    return result;
}

void heapSort(std::vector<Participant>& participants)
{
    std::vector<Participant> heap(1);

    for (const auto& p : participants)
        heapAdd(heap, p);

    int i = 0;
    while (heap.size() > 1)
        participants[i++] = popMax(heap);
}

int main()
{
    int n = 0;
    std::cin >> n;

    std::vector<Participant> participants(n);
    for (int i = 0; i < n; ++i)
        std::cin >> participants[i];

    heapSort(participants);

    for (int i = 0; i < n; ++i)
        std::cout << participants[i].name << std::endl;

    return 0;
}