// Отчет https://contest.yandex.ru/contest/24810/run-report/60230754/

/*
-- ПРИНЦИП РАБОТЫ --

Задача - удалить узел P со значением ключа key из бинарного дерева поиска. Ключи — уникальные целые числа.
Алгоритм состоит из следующих шагов:
1. Поиск узла, начиная с корня: 
Если значение текущего узла больше key - продолжить поиск в левом поддереве, т.к. значения в нем меньше текущего 
узла, если значение меньше - продолжить поиск в правом поддереве, иначе - узел найден.
2. Далее возможны следующие ситуации:
2.1. Удаляемый узел - это лист. В этом случае при возврате из рекурсии соответствующий потомок (левый или правый)
родительского узла будет заменен на nullptr. 
2.2. У удаляемого узла есть два дочерних узла. Для того, чтобы дерево не распалось, нужно на место удаляемой 
вершины поставить другую вершину. Ее значение должно быть больше всех значений в левом поддереве удаляемой вершины,
или меньше всех значений в правом поддереве. Т.е. это должна быть самая правая вершина в левом поддереве или 
самая левая вершина в правом поддереве. Будем брать самую правую вершину в левом поддереве.

Пусть parent указывает на текущую вершину, которую нужно удалить. Сurrent будет корнем левого поддерева этой вершины.
Будем спускаться по правым веткам левого поддерева, пока не придем в самый правый узел с нулевым правым ребенком.
При этом parent будет указывать на родителя current узла. В результате возможы следующие варианты:

- parent будет равен удаляемому узлу. Узел current не будет иметь правого ребенка. Тогда можно
переписать значение удаляемого узла на current->value (т.к. он является самым правым в левой поддереве)
и обновить левого ребенка на следующий за current левый узел - current->left. Свойство дерева не будет нарушено,
т.к. parent->left->left->value < parent->left->value < parent->value, parent->right->value > parent->value,
=> parent->left->value < parent->right->value, parent->left->left->value < parent->left->value.

Пример:
             8                           8
           /   \         delete 13     /   \
          4     13       --------->   4     10
               /  \                        /  \
              10   14                     9   14
             /                            
            9

- parent не равен удаляемому узлу, т.е. предпоследний узел на правой ветке поддерева. Тогда можно
переписать значение удаляемого узла на current->value (т.к. он является самым правым в левой поддереве) и
обновить правого ребенка parent на current->left, т.к. правый узел у current нулевой, а левый может 
существовать и будет гарантируемо больше parent->value по свойству бинарного дерева поиска.
Т.е. свойство бинарного дерева поиска не нарушится.

Пример:

             8                            8
           /   \          delete 14     /   \
          4     14       --------->    4     13
               /  \                         /  \
              10   15                      10   15
             / \                          / \
            9  11                        9  11
                \                            \
                13                           12
               /
             12

На выходе из функции вернем обновленный root узел, чтобы связать его с родителем.

2.3. У удаляемого узла есть только левый ребенок. Значит, в качестве текущего обновленного узла возвращаем левого ребенка.
2.4. У удаляемого узла есть только правый ребенок - возвращаем правого ребенка.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --

Корректность алгоритма - сохранение свойств бинарного дерева поиска и его целостности после удаления.
Рассмотрим ситуации из пункта 2.
2.1. Удаляемый узел - это лист. При удалении целостность и свойства дерева не будут нарушены.
2.2. У удаляемого узла есть два дочерних узла. Для того, чтобы дерево не распалось, нужно на место удаляемой 
вершины поставить другую вершину. Ее значение должно быть больше всех значений в левом поддереве удаляемой вершины,
или меньше всех значениям в правом поддереве. Т.е. это должна быть самую правая вершина в левом поддереве или 
самую левую вершина в правом поддереве. Тогда свойства дерева сохранятся. При переносе самой правой вершины 
свойства дерева также сохраняются, как было описано в п. 2.2.
2.3. У удаляемого узла есть только левый ребенок. Пусть parent - родитель удаляемой вершины.
Если удаляемый узел - правый ребенок parent, то левый ребенок удалемого узла будет больше parent->value
по свойству бинарного дерева поиска. Значит можно заменить правого ребенка parent на current->left.
Пример:
             8                           8
           /   \         delete 10     /   \
          4     10       --------->   4     9
               /
              9

Если удаляемый узел - левый ребенок parent, то левый ребенок удалемого узла будет меньше parent->value
по свойству бинарного дерева поиска. Значит можно заменить левого ребенка parent на current->left.

Пример:
            11                           11
           /   \         delete 10     /   \
         10     12       --------->   9     12
        /                                     
       9                              
      
2.4. У удаляемого узла есть только правый ребенок. Пусть parent - родитель удаляемой вершины.
Если удаляемый узел - правый ребенок parent, то правый ребенок удалемого узла будет больше parent->value
по свойству бинарного дерева поиска. Значит можно заменить правого ребенка parent на current->left.
Если удаляемый узел - левый ребенок parent, то правый ребенок удалемого узла будет меньше parent->value
по свойству бинарного дерева поиска. Значит можно заменить левого ребенка parent на current->left.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --

Временная сложность операции удаления составляет O(h), где h - высота двоичного дерева поиска.
Если n - число узлов в бинарном дереве поиска, то среднее время удаления - O(log n) для 
сбланасированного дерева. Пусть узел, который требуется найти, находится на глубине k, 
тогда на поиск узла потребуется O(k). Далее, на поиск самого правого ребенка потрбуется 
O(h - k) времени.
В худшем случае, если дерево является списком и нужно удалить листовой узел,
сложность составит - O(n), т.к. поторебуется перебрать все узлы.

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --

Требуется хранить дерево. Пространственная сложность будет равна O(n), где n - число узлов в дереве.

*/

struct Node
{
  Node* left;
  Node* right;
  int value;
};

//#include "solution.h"
#include <cassert>

Node* remove(Node* root, int key)
{
    if (!root)
        return nullptr;

    if (root->value > key)
    {
        root->left = remove(root->left, key);
    }
    else if (root->value < key)
    {
        root->right = remove(root->right, key);
    }
    else //root->value == key
    {
        // нет детей
        if (!root->left && !root->right)
            return nullptr;
        // есть оба ребенка
        else if (root->right && root->left)
        {
            Node* parent = root;
            Node* current = root->left;
            while (current->right)
            {
                parent = current;
                current = current->right;
            }

            if (parent == root)
            {
                root->value = current->value;
                parent->left = current->left;
            }
            else
            {
                root->value = current->value;
                parent->right = current->left;
            }
        }
        else if (!root->right)
            root = root->left;
        else // !root->left
            root = root->right;
    }
    return root;
}

void test() {
    Node node4({ nullptr, nullptr, 1 });
    Node node5({ nullptr, nullptr, 3 });
    Node node6({ nullptr, nullptr, 5 });
    Node node7({ nullptr,nullptr, 7 });

    Node node3({ &node6, &node7, 6 });
    Node node2({ &node4, &node5, 2 });
    Node node1({ &node2, &node3, 4 });

    Node* newHead = remove(&node1, 2);
}


int main()
{
    test();
    return 0;
}