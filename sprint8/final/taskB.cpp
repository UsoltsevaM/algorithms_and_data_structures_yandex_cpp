// Отчет https://contest.yandex.ru/contest/26133/run-report/64863269/

/*
-- ПРИНЦИП РАБОТЫ --

Для эффективного поиска слов из заданной строки используется структура данных префиксное дерево.
Ребра в таком дереве соответствую символам алфавита, узлы  - могут быть 2х типов: терминальные
узлы - это узлы, соответствующие добавленным словам, промежуточные - они ни не соответствуют
никакому слову, но являются префиксами для одного или нескольких слов, находящихся в дереве.
Путь от корня до узла, соответствующий добавленному слову, проходит по цепочке узлов, каждый из
которых соответствует префиксу исходного слова.
Каждый узел TrieNode дерева хранит массив переходов children (указателей на узлы) длины sAlphabetSize
- размера алфавита. Таким образом, переход по ребру в следующий узел, т.е. выбор некоторого следующего
i-го символа в слове, будет соответствовать переходу в дочерний узел с индексом i - pNode->children[i].
Также в узле хранится метка endOfWord, соотвествующая типу узла - true - терминальный узел
(конец слова), false - промежуточный узел (префикс, не являющийся словом).

Алгоритм решения:
1. Построить префиксное дерево по заданному набору слов S1, ... , Sk.
Функция createTrieNode() создает узел дерева и заполняет nullptr все дочерние узлы, помечает
узел промежуточным - endOfWord = false.

Функция void insert(TrieNode* pRoot, const std::string& word) - вставляет слово word в дерево с
корнем pRoot, т.е. проходит по ребрам от корня до узла, соответствующего добавляемой строке:
* Считать следующий символ слова;
* Перейти по ребру, соответствующему текущему символу, в следующий узел pCurrent->children[charIdx],
если оно существует;
* Если такого ребра не существует - создать необходимое ребро и узел соответствующий данному префиксу
pCurrent->children[charIdx] = createTrieNode();
* Когда будут просмотрены все символы слова, последний текущий узел будет помечен терминальными
- endOfWord = true.

2. Функция breakIntoWords(TrieNode* pRoot, const std::string& str) определяет, существует ли
возможное разбиение строки на заданный набор слов в дереве.

Trie будет играть роль шаблона. Будем перебирать возможные стартовые позиции исходной строки, к которым
можно приложить шаблон. Символы строки будут задавать путь по префиксному дереву. Если путь по
существующим ребрам дерева проложить не удается, шаблон в текущей стартовой позиции не подходит.
Если же алгоритм в процессе движения по ребрам дошел до одного из терминальных узлов, шаблон найден.
(https://practicum.yandex.ru/learn/algorithms/courses/ - тема "Префиксное дерево").

Массив strDivision хранит массив стартовых позиций, с которых будет начинаться поиск шаблона в
исходной строке str. strDivision[0] = true - поиск начинается с нулевого символа строки.

Во внешнем цикле for (size_t i = 0; i < str.length(); i++) будем идти по символам строки str
последовательно. Во внутреннем цикле for (size_t j = i; pCurrent && j < str.length(); j++) происходит
перемещение по ребрам дерева trie, начиная с корня, согласно символам исходной строки пока не произойдет
расхождение с ребром деревом (т.е. в дереве не окажется следующего ребра, соответвующего символу j)
или не закончатся символы строки. При этом если был достигнут терминальный узел, т.е. в строке str
найдено слово из trie, то помечаем strDivision[j + 1] = true - это следующий символ за последним
символом найденного слова. В случае расхождения с trie, вернемся к первой ненулевой позиции из массива
strDivision, большей текущего i и продолжим построение разбиения. Позиции символов для которых
strDivision[i] = false рассматривать не нужно, т.к. мы ищем непрерывное разбиение исходной строки на
слова из trie.

Т.е. для каждого поиска в trie, начиная с некоторой позиции i + 1 строки str мы имеем некоторое разбиение
строки str на интервалы [0, i] и [i + 1, j]. [0, i] соответствует найденному разбиению строки str[0, i]
на слова из trie, интервал [i + 1, j] будет проанализирован на совпадение с шаблоном во внутреннем цикле.
Таким образом, после итерации по всем символам исходной строки, приложив шаблон (trie) ко всем ненулевым
позициям из strDivision мы найдем все возможные разбиения исходной строки на слова.
При этом если strDivision[str.length()] = truе, то искомое разбиение строки на слова из trie удалось построить,
т.к. последний символ строки соответвует окончанию последнего слова из непрерывного разбиения.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --

Пример:

Строка          str          exampassiwill
Массив позиций  strDivision  10001000110001

На позициях 0, 4, 8, 9, 13 стоят единицы, это значит, что перед ними было обнаружено слово из trie
(за исключением 0й позиции - можно считать, что была обнаружена пуста строка - "").

Структура trie обеспечивает перебор всех слов, по которым она построена. Будем использовать это свойство.

Докажем, что алгоритм строит корректное разбиение. Пусть это не так. Это значит,
что есть некоторое strDivision[i] = true, но нет слова которое бы заканчивалось перед позицией i.
Но это невозможно, т.к. мы пишем true только когда слово есть в trie.

Докажем, что алгоритм рассматривает все возможные корректные комбинации слов, образующих разбиение исходной строки.
Пусть это не так. Тогда существует слово, которое входит в строку начинающееся с позиции i и strDivision[i] = false.
Если strDivision[i] = false, то возможны 2 варианта:
1. Перед текущим словом не было предыдущего, что означает разрыв в разбиение строки. Это противоречит,
тому что мы рассматриваем корректное разбиение строки.
2. Перед текущим словом было предыдущее слово, но мы его не рассмотрели. Такое может быть
только если оно начиналось с некоторой позиции k, такой что strDivision[k] = false.
Продолжая рассуждения по индукции, приходим к позиции strDivision[0] = false. Согласно алгоритму
strDivision[0] = true. Получили противоречие.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --

Построение дерева:
При добавлении каждого слова нужно выполнить количество операций, пропорциональное его длине.
Сложность создания trie - O(L), где L = S1 + ... + Sn — суммарная длина слов во исходном множестве.

Разбиение строки на слова:
Пусть n - длина исходной строки str. M - максимальная глубина trie, M = max{length(S1),...,length(SN)} + 1.
Внешний цикл for (size_t i = 0; i < str.length(); i++) выполняется n раз.
В худшем случае на каждой итерации будет выполненен поиск в trie, который занимает O(M).
Общая сложность - O(n * M).

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --

Пусть M - максимальная глубина trie, M = max{length(S1),...,length(SN)} + 1, соответствует самому длинному слову.
N - общее число слов S1, .. SN в trie (в худшем случае каждый символ каждого слова занимает отдельный узел).  
Каждый узел хранит sAlphabetSize потомков. Тогда общая сложность - O (N * M * sAlphabetSize).

Кроме того, для массива позиций потребуется O(n) памяти, где n - длина исходной строки str, которую нужно разбить.
Общая сложность - O(N * M * sAlphabetSize + n).

*/

#include <iostream>
#include <vector>
#include <string>

const size_t sAlphabetSize = 26;

struct TrieNode
{
    TrieNode* children[sAlphabetSize];

    bool endOfWord = false;
};

TrieNode* createTrieNode()
{
    TrieNode* pNode = new TrieNode;
    pNode->endOfWord = false;

    for (size_t i = 0; i < sAlphabetSize; i++)
        pNode->children[i] = nullptr;

    return pNode;
}

void freeTrie(TrieNode* pCurrent)
{
    if (!pCurrent)
        return;

    for (size_t i = 0; i < sAlphabetSize; i++)
        freeTrie(pCurrent->children[i]);

    delete pCurrent;
}

void insert(TrieNode* pRoot, const std::string& word)
{
    TrieNode* pCurrent = pRoot;

    for (size_t i = 0; i < word.size(); i++)
    {
        int charIdx = word[i] - 'a';
        if (!pCurrent->children[charIdx])
            pCurrent->children[charIdx] = createTrieNode();

        pCurrent = pCurrent->children[charIdx];
    }

    pCurrent->endOfWord = true;
}

bool breakIntoWords(TrieNode* pRoot, const std::string& str)
{
    std::vector<bool> strDivision(str.length() + 1, false);
    strDivision[0] = true;

    for (size_t i = 0; i < str.length(); i++)
    {
        if (!strDivision[i])
            continue;

        TrieNode* pCurrent = pRoot;
        for (size_t j = i; pCurrent && j < str.length(); j++)
        {
            int charIdx = str[j] - 'a';
            pCurrent = pCurrent->children[charIdx];

            if (pCurrent && pCurrent->endOfWord)
                strDivision[j + 1] = true;
        }
    }

    return strDivision[str.length()];
}

int main()
{
    std::string str;
    std::cin >> str;

    int n = 0;
    std::cin >> n;

    TrieNode* pRoot = createTrieNode();

    std::string word;
    for (int i = 0; i < n; i++)
    {
        std::cin >> word;
        insert(pRoot, word);
    }

    if (breakIntoWords(pRoot, str))
        std::cout << "YES";
    else
        std::cout << "NO";

    freeTrie(pRoot);

    return 0;
}