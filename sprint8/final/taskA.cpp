// Отчет https://contest.yandex.ru/contest/26133/run-report/65014621/

/*
-- ПРИНЦИП РАБОТЫ --

Идея решения заключается в том, чтобы для уменьшения затрат памяти считывать и декодировать
строки по одной, находя наибольший общий префикс набора строк LCP(S1...Si) как наибольший
общий префикс строки LCP(LCP(LCP(S1,S2),S3),...Si-1) и строки Si. Si - строка считываемая
и декодируемая на текущей iй итерации цикла.

Для заданного набора строк размера n получим:
LCP(S1...Sn) = LCP(LCP(LCP(S1,S2),S3),...Sn).

int LCPLength(const std::string& str1, const std::string& str2, int prevPrefixLength)
возвращает количество символов НОП строки str1 до prevPrefixLength - 1 символа и строки str2. 
На шаге i НОП - это [0, i) символов первой строки str1 в декодированном виде.
Конечным результатом будет подстрока строки str1 последнего вычисленного НОП - str1.substr(0, prefixLength).

Для декодирования строки используются два стека - для чисел (количества повторений строки
при распаковке) и для строк (внутри скобок).

При итерации по символам строки возможны следующие случаи:
1. Символ является цифрой - превращаем символ в число и кладем на стек, т.к. по условию
число однозначное.
2. Символ является буквой - пока считываемый символ буква, собираем строку из букв и
помещаем на стек.
3. Символ является открывающейся скобкой - помещаем строку "[" на стек.
4. Символ является закрывающейся скобкой.
    * Достаем из стека все строки S{i}, S{i-1}, S{i-2}, ..., S{i-l} до открывающейся скобки "]".
    * Производим конкатенацию строк в обратном порядке word = S{i-l} + ... + S{i-2} + S{i-1} + S{i}.
    * Убираем строку "[" со стека. word - является распакованным выражением между рассмотренной парой скобок.
    * Достаем со стека чисел число k равное количеству повторений текущей строки word.
    * Записываем в распакованную строку extractedWord k строк word.
    * Кладем extractedWord обратно на стек.

Когда достигнут конец строки и стек не пуст, нужно извлечь все оставшиеся строки
со стека S{j}, S{j-1}, S{j-2}, ..., S{0} и произвести конкатенацию строк в обратном порядке -
extractedString = S{0}... + S{j-2} + S{j-1} + S{j}. extractedString будет искомой декодированной
строкой.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --

Наибольший общий префикс:
Требуется доказать, что НОП строк S1...Sn преставим как:
LCP(S1...Sn) = LCP(LCP(LCP(S1,S2),S3),...Sn).

Заметим, что функция LCP обладает свойством ассоциативности, т.е. для 3х строк S1, S2, S3
LCP(S1,S2,S3) = LCP(LCP(S1,S2),S3) = LCP(S1,LCP(S2,S3))

Последовательно применяя это свойство к выражениям в скобках, получим:
LCP(LCP(LCP(S1,S2),S3),...Sn) = LCP(LCP(S1,S2,S3),...Sn) = LCP(S1...Sn).

Пример:

"abca"  "abce" "abdg"
   \     /       |
    "abc"        |
       \         /
        \       /
         \     /
           "ab"

LCP("abca", "abce", "abdg") = LCP(LCP("abca", "abce"), "abdg") = LCP("abc", "abdg") = "ab".

Декодирование:
Вложенная рекурсивная структура эквивалентна дереву с листовыми узлами, содержащими строки
определенного уровня вложенности. Ребра помечены коэффициентами дублирования строк в скобках. Глубина дерева
равна максимальной вложенности скобок + 1. Нелистовые узлы переставляют собой пустые строки.

Пример:

Строка:  a2[bc3[a]]d

Дерево:

    ""
   / | \
1 / 2|  \ 1
 /   |   \
a   ""    d
   1/ \3
   /   \
  bc    a

Декодирование строки эквивалентно обходу дерева в глубину слева направо. При возвращении из листового узла происходит
дублирования строки k раз, где k - метка ребра. Результаты обработки всех дочерних узлов текущего родительского узла
запоминаются на стеке. Далее, после обработки всех дочерних узлов происходит объединение строк этих узлов, результат которого
соответствует распакованной строке поддерева. На стеке это соответствует снятию и конкатенации строк, заключенных между
текущей парой скобок. Результат конкатенации помещается на стек - он представляет собой обработку корня текущего поддерева.
Действия повторяются пока в результате обхода не будет достигнут корень дерева. Для корня исходного дерева дочерние узлы
будут обработаны аналогичным образом и конкатенация их строк даст искомую декодированную строку.

    ""
   / | \
1 / 2|  \ 1   ->  abcaaabcaaad
 /   |   \
a  bcaaa  d

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --

Пусть n - число строк из m символов в декодированном виде.
Тогда временная сложность равна поиску наибольшего общего префикса O (n * m).
Худший случай - когда все строки совпадают. На каждой из n итераций происходит
сравнение подстроки строки S1 со строкой Si, i = 2, ... n. Сравнение происходит за O(m), т.к.
в худшем случае требуется перебрать все m символов строки.

Кроме того на каждой итерации цикла происходит декодирование строки.
Для сложности декодирования имеют значения коэффициенты дублирования в сжатой строке, т.е.
фактически его сложность зависит от длины m строки в декодированном виде, т.е. O(m).

Cоответственно общая сложность алгоритма O(n * (m + m)) = O (n * m).

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --

O(m) требуется в худшем случае для хранения 2х стеков для декодирования строки из m символов в функции decode().
O(m) памяти требуется для хранения декодированной строки.

На каждой итерации цикла требуется O(m) памяти для декодируемой строки decodedStr, O(1) для храненения текущей 
длины НОП prefixLength и O(m) памяти для функции decode(), которая может быть переиспользована после выхода из функции.

Общие затраты памяти - O(m).

*/

#include <iostream>
#include <vector>
#include <string>
#include <stack>
#include <cctype>

std::string decode(const std::string& str)
{
    std::stack<std::string> strStack;
    std::stack<int> numStack;

    for (int i = 0; i < str.size();)
    {
        if (std::isdigit(str[i]))
        {
            numStack.push(str[i] - '0');
            i++;
        }
        else if (std::isalpha(str[i]))
        {
            std::string word;
            while (std::isalpha(str[i]) && i < str.size())
                word += str[i++];
            strStack.push(word);
        }
        else if (str[i] == '[')
        {
            strStack.push("[");
            i++;
        }
        else if (str[i] == ']')
        {
            std::string word;
            while (strStack.top() != "[")
            {
                word = strStack.top() + word;
                strStack.pop();
            }

            strStack.pop(); // убрать "["

            int k = numStack.top();
            numStack.pop();

            std::string extractedWord;
            for (int j = 0; j < k; j++)
                extractedWord += word;

            strStack.push(extractedWord);

            i++;
        }
    }

    std::string extractedString;
    while (!strStack.empty())
    {
        extractedString = strStack.top() + extractedString;
        strStack.pop();
    }

    return extractedString;
}

int LCPLength(const std::string& str1, const std::string& str2, int prevPrefixLength)
{
    if (str1.empty() || str2.empty())
        return 0;

    for (int i = 0; i < prevPrefixLength; i++)
        if (str2[i] != str1[i] || str2.length() == i)
            return i;

    return prevPrefixLength;
}

int main()
{
    int n = 0;
    std::cin >> n;

    std::string str1;
    std::cin >> str1;

    str1 = decode(str1);
    int prefixLength = str1.length();

    std::string str;
    for (int i = 1; i < n; i++)
    {
        std::cin >> str;
        auto decodedStr = decode(str);

        prefixLength = LCPLength(str1, decodedStr, prefixLength);
    }

    std::cout << str1.substr(0, prefixLength);

    return 0;
}