// Отчет https://contest.yandex.ru/contest/22781/run-report/55181386/

/*
-- ПРИНЦИП РАБОТЫ --
Реализовано вычисление выражения, записанного в обратной польской нотации,
с использованием стека.

Вычисление происходит согласно следующему алгоритму:

1. Считать подстроку до разделителя ' ' или конца строки из исходной строки выражения (слева направо)
2. Обработка входной подстроки:
* Если на вход подан операнд, он помещается на вершину стека.
Для преобразования строки в число используется std::stoi().
Считаем, что ввод корректен - на входе всегда или число или знак операции.
* Если на вход подан знак операции, то эта операция выполняется над двумя операндами,
взятыми из стека в порядке добавления. Результат выполненной операции помещается на вершину стека.
* Если входной набор символов обработан не полностью, перейти к шагу 1.

После полной обработки входного набора символов результат вычисления выражения находится в вершине стека.
Если в стеке осталось несколько чисел, то надо вывести только верхний элемент (пример: 1 1 + 1 1 - вывод:0).

Деление с остатком согласно алгоритмам в статье - https://zaochnik.com/spravochnik/matematika/dejstvitelnye-ratsionalnye-irratsionalnye-chisla/delenie-tselyh-chisel-s-ostatkom/
* (operand1 > 0 && operand2 > 0) => abs(operand1) / abs(operand2)
* (operand1 > 0 && operand2 < 0) => abs(operand1) / abs(operand2) * (-1)
* (operand1 < 0 && operand2 > 0) => abs(operand1) / abs(operand2) * (-1) - round
* (operand1 < 0 && operand2 < 0) => abs(operand1) / abs(operand2) * + round
Где round = 1, в в случае, если operand1 не делится на operand2 без отстатка

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Алгоритм корректен согласно определению обратной польской нотации:

* Запись набора операций состоит из последовательности операндов и знаков операций.
Операнды в выражении при письменной записи разделяются пробелами.
* Все операнды в обратной польской нотации расположены перед знаком операции.
* Выражение читается слева направо. Когда в выражении встречается знак операции,
выполняется соответствующая операция над двумя последними встретившимися перед ним операндами в порядке их записи.
Этими числами будут являться числа, извлеченные с вершины стека, т.к. стек поддерживает LIFO.
* Результат операции заменяет в выражении последовательность её операндов и её знак, для этого результат
помещается на стек. Он будет являться операндом следующей операции.
После чего выражение вычисляется дальше по тому же правилу.

* Результатом вычисления выражения становится результат последней вычисленной операции, т.е. значение на
вершине стека.

Пример: 1 2 3 + * -> 1 5 * -> 5
1. 1, 2, 3 - будут помещены на стек
1. Первая операция в строке "+". Сначала выполнится сложение 2х операндов 2 и 3.
На стеке останется 1.
2. Значение 5, заменит "2 3 +" в выражении - 1 5 *.
3. Далее на стек добавится 5 - 1, 5.
4. Следующая операция *. 1 * 5 = 5. Значение помещено на стек.
5. Указатель достиг конца строки. Результат вычислений - 5.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Пусть s - входная строка символов, состоящая из n чисел и m операций, s = n + m
Последовательная итерация по элементам строки будет O(s).
Для операции в исходном выражении при этом будет выполненено:
* Снятие 2х последних элементов со стека - O(1)
* Преобразование подстроки с символом операции в мат. операцию O(1)
* Выполнение соответствующей математической операции - O(1)
* Добавление на стек O(1)
Для операнда:
* Преобразование строки в число O(1)
32-битное целое число содержит не более 11 символов.
В строке достаточно проверить первые 11 символов, чтобы убедиться,
что это действительный 32-битный целое или нет. Сложность не зависит от размера строки.
* Добавление числа на стек O(1)

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Пусть s - входная строка символов, состоящая из n чисел и m операций, s = n + m
Операции не хранятся на стеке. В худшем случае для выражения вида
num1 num2 ... num_n op1 op2 ... op_m потребуется O(n) памяти.
В лучшем случае на стеке будет храниться 2 операнда -  O(1).

В общем случае максимальный размер стека будет равен максимальной длине
последовательности из чисел идущих друг за другом до знака операции в выражении.
*/

#include <iostream>
#include <stack>
#include <string>
#include <cmath>
#include <cassert>
#include <sstream>

class Calculator
{
public:
	int calulcate(const std::string& expression)
	{
		std::stack<int> stack;
		std::string symbol;
		std::istringstream stream(expression);

		while (std::getline(stream, symbol, sDelimeter))
		{
			if (isOperator(symbol))
			{
				if (stack.size() > 1)
				{
					int operand2 = stack.top();
					stack.pop();

					int operand1 = stack.top();
					stack.pop();

					int result = executeOperator(symbol[0], operand1, operand2);
					stack.push(result);
				}
			}
			else
			{
				stack.push(std::stoi(symbol));
			}
		}

		return stack.top();
	}

private:
	static const char sDelimeter = ' ';

	bool isOperator(const std::string& str)
	{
		return str == "+" || str == "-" || str == "*" || str == "/";
	}

	int sign(int val)
	{
		return val < 0 ? -1 : 1;
	}

	int divide(int operand1, int operand2)
	{
		assert(operand2 != 0);

		int quotient = std::abs(operand1) / std::abs(operand2);
		int round = (std::abs(operand1) % std::abs(operand2)) > 0 ? 1 : 0;

		return operand1 > 0 ? (sign(operand2) * quotient) : (-sign(operand2) * (quotient + round));
	}

	int executeOperator(char operation, int operand1, int operand2)
	{
		switch (operation)
		{
		case '+':
			return operand1 + operand2;
		case '-':
			return operand1 - operand2;
		case '*':
			return operand1 * operand2;
		case '/':
			return divide(operand1, operand2);
		default:
			assert(true);
		}

		return -1;
	}
};

int main()
{
	std::string expression;
	std::getline(std::cin, expression);

	Calculator calc;
	std::cout << calc.calulcate(expression);

	return 0;
}